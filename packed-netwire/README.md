So, welcome to my first entry of **Skiddie Malware Reversing**.

Hopefully, there will be many more in future.

The first target will be **newcrypt.exe**:  
* File size: 311 808 bytes
* CRC32: `A404D72F`
* MD5: `C68BBD88F397785444EF89F55223D461`
* SHA-1: `FA77EA1DE56DE75913F370FD26B581E93984C896`

Checking the resources, it has description `Display Driver Software `, original filename of `mbamsks.exe`, and oddly, a build time there, of `6/2/2015 5:13:37 PM`, though the 13:37 makes me think it's faked. I also don't know if this is dd/mm/yy or mm/dd/yy.

First up, old trusty exeinfope. Which tells me this is a .NET assembly. Skids do love their .NET.  
Throwing it in reflector shows some kind of obfuscation: de4dot easily handles that.  
Some browsing in reflector then points me to this resource:

![Suspicious resource](https://wack0.github.io/skiddie-malware-reversing/packed-netwire/scrn1.png)

What is that? `4D-5A`? An EXE, hex-encoded with each byte delimited by `-`?  
\*copy-paste, `s/-//\` and save as hex.txt\*  
One `php -r "file_put_contents('hex.bin',pack('H*',file_get_contents('hex.txt')));"` later, and...

![Hex dump](https://wack0.github.io/skiddie-malware-reversing/packed-netwire/scrn2.png)

That sure looks like a PE executable to me... And exeinfope shows this is a .NET assembly, a DLL (lack of entrypoint).  
So, let's open it in reflector.

![Classes list](https://wack0.github.io/skiddie-malware-reversing/packed-netwire/scrn3.png)

Why, yes, that does look malicious, and this seems to be the main "core" of the crypter/packer, it containing anti-VM/anti-sandboxie and RunPE functions.

The entry point function that the original exe calls after loading the assembly seems to be `OYExEov()`, so let's take a look.

The first lines that stand out for me?

        int timestamp = GetTimestamp();
        object[] objArray = new Pack().Deserialize(Decrypt(ReadManagedResource(), timestamp.ToString()));

`GetTimestamp()` ... gets the compilation timestamp from the PE header.  
`ReadManagedResource()` seems to assemble a bitmap out of a pile of resource chunks in the original exe, then it calls `ConvertFromBitmap()` -- well, from previous experience I know that shitty steganography is all the rage among skiddies' crypters/packers these days.  
(I note `ConvertFromBitmap()` converts a pointer to a 64-bit signed integer, adds 4 to it, and creates another pointer from that. Which means this won't work on 32-bit platforms.)  
`Decrypt()`... well, the purpose of that is obvious. Simple XOR is used. However, the way the key is used is not so simple. A PRNG instance is created using the first 4 bytes of the passed in encrypted data as a DWORD. Each byte of the XOR pad is created by taking the next value from that PRNG instance (using maxValue parameter of `Random.Next()` to make sure it can fit in one byte). A byte of the key is added to this value (taken in the way I find is "usual", data offset modulo data length). Lastly, the value is ANDed with 255 and converted to a byte.  
`Pack.Deserialize()`... the purpose of this is also obvious, to deserialise some binary data into a .NET object array. I'll come back to it later.

So, let's get the PE timestamp of the exe file. It's `0x559D22E9`, which can also be represented as 8th July 2015, 13:17:29.  
The next thing to do, would obviously be to decrypt this binary data.  
\*some copy-pasting of code out of Reflector and modifying it later\*

    >C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc decme.cs
    Microsoft (R) Visual C# Compiler version 4.6.0079.0
    for C# 5
    Copyright (C) Microsoft Corporation. All rights reserved.
    
    This compiler is provided as part of the Microsoft (R) .NET Framework, but only supports language versions up to C# 5, which is no longer the latest version. For compilers that support newer versions of the C# programming language, see http://go.microsoft.com/fwlink/?LinkID=533240
    
    
    >decme
    
    >

I modified the code to extract the original bitmap as `bmp.bmp`, and the decrypted data as `Data.bin`.  
The bitmap has 69165px by 1px dimensions. Subtle...  
Meanwhile, the data structure.  
Essentially, the byte at offset 0 is the number of elements, which follows by element identifier, and then data corresponding to that element.  
The element identifier of a byte array is `2`, and raw bytes follow a length DWORD.  
And guess what the first element of this data structure is. A byte array containing a PE file, that's `0x32A00` bytes in length.  
So let's unpack it.

    >dd if=Data.bin of=Unpacked.exe skip=6 bs=1 count=207360
    207360+0 records in
    207360+0 records out
    207360 bytes (207 kB) copied, 1.495 seconds, 139 kB/s
    
    >

It's another .NET binary. No version info in the resources. However, the assembly name is `NanoCore Client.exe`, instantly identifying what this sample is, a NanoCore RAT.

As far as extracting the config goes, [Kevin Breen's RATDecoders](https://github.com/kevthehermit/RATDecoders) work perfectly there:

    Key: BypassUAC	 Value: 00
    Key: ClearAccessControl	 Value: 00
    Key: ClearZoneIdentifier	 Value: 01
    Key: ConnectDelay	 Value: 4000
    Key: Domain1	 Value: destinywatch.chickenkiller.com
    Key: Domain2	 Value: 
    Key: EnableDebugMode	 Value: 00
    Key: Group	 Value: Default
    Key: Mutex	 Value: 03dc9007e6b71e47ae108aa33a8f4b1d
    Key: Port	 Value: 3400
    Key: PreventSystemSleep	 Value: 01
    Key: PrimaryDNSServer	 Value: 8.8.8.8
    Key: RequestElevation	 Value: 00
    Key: RestartDelay	 Value: 5000
    Key: RunOnStartup	 Value: 01
    Key: SetCriticalProcess	 Value: 00
    Key: UseCustomDNS	 Value: 01
    Key: Version	 Value: 1.2.2.0

Yay, another RAT with dynamic DNS?

    * Dns resolved destinywatch.chickenkiller.com to 99.244.122.106
    * Dns resolved 99.244.122.106 to CPEbc14012fc8f3-CMbc14012fc8f0.cpe.net.cable.rogers.com

Yup, as expected, it's hosted on someone's home connection...  